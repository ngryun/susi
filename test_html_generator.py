import pandas as pd
from pathlib import Path
from html_generator import plot_selected_depts 
import json 
import re 

# 1. Create a sample Pandas DataFrame (New data as per subtask)
data = {
    'univ': ['대학A', '대학A', '대학B', '대학A', '대학B', '대학A'],
    'subtype': ['전형1', '전형1', '전형2', '전형1', '전형2', '전형1'],
    'dept': ['학과X', '학과X', '학과Y', '학과X', '학과Y', '학과X'],
    'result': ['합격', '충원합격', '불합격', '합격', '불합격', '충원합격'],
    'conv_grade': [1.5, 1.7, 2.5, 1.3, 2.8, 1.9],
    'all_subj_grade': [1.6, 1.8, 2.6, 1.4, 2.9, 2.0]
}
sample_df = pd.DataFrame(data)
output_dir = Path("output_htmls_test")
output_dir.mkdir(parents=True, exist_ok=True)
output_filename = "test_report.html"

# 2. Call plot_selected_depts
print(f"Generating HTML report to {output_dir/output_filename}...")
generation_result = plot_selected_depts(
    sample_df, 
    output_dir, 
    selected_depts=['학과X', '학과Y'], 
    selected_univs=['대학A', '대학B'], 
    selected_subtypes=['전형1', '전형2'], 
    output_file=output_filename
)
print(generation_result)

# 3. Read the generated HTML file
html_file_path = output_dir / output_filename
html_content = ""
if html_file_path.exists():
    with open(html_file_path, 'r', encoding='utf-8') as f:
        html_content = f.read()
    print(f"Successfully read {html_file_path}")
else:
    print(f"ERROR: HTML file not found at {html_file_path}")
    html_content = "HTML FILE NOT GENERATED"


failures = []
if html_content == "HTML FILE NOT GENERATED":
    failures.append("Critical: HTML file was not generated by plot_selected_depts.")

# 4. Verify the HTML content

# Hovertemplate Check
print("\n--- Hovertemplate Check ---")
if not failures: 
    script_tags = re.findall(r'<script>(.*?)</script>', html_content, re.DOTALL)
    plot_data_script_matches = [
        match for s in script_tags 
        if (match := re.search(r'window\.plotsData\["(\d+)"\]\s*=\s*(\{.*?\});', s, re.DOTALL))
    ]

    if not plot_data_script_matches:
        if not any('window.plotsData' in s for s in script_tags):
            failures.append("Hovertemplate Check: No script tag found containing 'window.plotsData'.")
        else:
            if not (re.search(r"convTraces:\s*\[", html_content) or re.search(r"allSubjTraces:\s*\[", html_content)):
                 print("Hovertemplate Check: Found 'window.plotsData' but no 'convTraces' or 'allSubjTraces', likely the main script block. Skipping detailed hovertemplate checks for this block.")
            elif not any('window.plotsData["1"]' in s for s in script_tags): 
                print("Hovertemplate Check: 'window.plotsData' found, and traces seem to exist, but specific plot ID format 'window.plotsData[\"id\"]' was not matched by regex. Will perform a general check.")
                general_hovertemplate_errors = []
                for i, s_content in enumerate(script_tags):
                    if 'window.plotsData' not in s_content: continue

                    conv_hovertemplates = re.findall(r"name:\s*'.*?',\s*marker:\s*\{.*?\},\s*hovertemplate:\s*'(환산등급:.*?extra>)'", s_content, re.DOTALL)
                    for ht in conv_hovertemplates:
                        if '{result}' in ht or '<br>' in ht:
                            general_hovertemplate_errors.append(f"General Hovertemplate Check (convTraces, script index {i}): Found '{{result}}' or '<br>' in hovertemplate: '{ht}'.")
                    
                    all_subj_hovertemplates = re.findall(r"name:\s*'.*?',\s*marker:\s*\{.*?\},\s*hovertemplate:\s*'(전교과등급:.*?extra>)'", s_content, re.DOTALL)
                    for ht in all_subj_hovertemplates:
                        if '{result}' in ht or '<br>' in ht:
                            general_hovertemplate_errors.append(f"General Hovertemplate Check (allSubjTraces, script index {i}): Found '{{result}}' or '<br>' in hovertemplate: '{ht}'.")
                
                if general_hovertemplate_errors:
                    failures.extend(general_hovertemplate_errors)
                else:
                    print("General Hovertemplate Check: No incorrect hovertemplates (containing {result} or <br>) found in general scan.")
    else: 
        for match_obj in plot_data_script_matches:
            plot_id_str = match_obj.group(1)
            plot_data_str = match_obj.group(2)
            
            try:
                conv_traces_match = re.search(r"convTraces:\s*\[(.*?)\]", plot_data_str, re.DOTALL)
                if conv_traces_match:
                    conv_traces_block_str = conv_traces_match.group(1)
                    individual_conv_traces = re.findall(r'(\{[\s\S]*?type\s*:\s*\'scatter\'[\s\S]*?\})(?=\s*,\s*\{|\s*\])', conv_traces_block_str, re.DOTALL)
                    if not individual_conv_traces and conv_traces_block_str.strip() and conv_traces_block_str.strip() not in ["{}", "[]"]:
                        if 'type:' in conv_traces_block_str: 
                           individual_conv_traces = [t.strip() for t in conv_traces_block_str.split('}, {') if t.strip()]

                    for trace_idx, trace_str in enumerate(individual_conv_traces):
                        if not trace_str.startswith('{'): trace_str = '{' + trace_str
                        if not trace_str.endswith('}'): trace_str = trace_str + '}'
                        
                        if "hoverinfo: 'skip'" in trace_str: 
                            continue
                        if not re.search(r'x:\s*\[\s*\]', trace_str): 
                            hovertemplate_match = re.search(r"hovertemplate:\s*'(.*?)'", trace_str)
                            if not hovertemplate_match:
                                failures.append(f"Hovertemplate Check (convTraces, plot_id {plot_id_str}, trace {trace_idx+1}): No hovertemplate found. Trace: {trace_str[:150]}...")
                            else:
                                ht = hovertemplate_match.group(1)
                                expected_ht = '환산등급: %{x}<extra></extra>'
                                if not (ht == expected_ht or ht == '환산등급: %{x}%<extra></extra>'): 
                                    failures.append(f"Hovertemplate Check (convTraces, plot_id {plot_id_str}, trace {trace_idx+1}): Incorrect. Expected '{expected_ht}', Got '{ht}'.")
                                if '{result}' in ht or '<br>' in ht: 
                                     failures.append(f"Hovertemplate Check (convTraces, plot_id {plot_id_str}, trace {trace_idx+1}): Found '{{result}}' or '<br>' in hovertemplate: '{ht}'.")

                all_subj_traces_match = re.search(r"allSubjTraces:\s*\[(.*?)\]", plot_data_str, re.DOTALL)
                if all_subj_traces_match:
                    all_subj_traces_block_str = all_subj_traces_match.group(1)
                    individual_all_subj_traces = re.findall(r'(\{[\s\S]*?type\s*:\s*\'scatter\'[\s\S]*?\})(?=\s*,\s*\{|\s*\])', all_subj_traces_block_str, re.DOTALL)
                    if not individual_all_subj_traces and all_subj_traces_block_str.strip() and all_subj_traces_block_str.strip() not in ["{}", "[]"]:
                        if 'type:' in all_subj_traces_block_str:
                            individual_all_subj_traces = [t.strip() for t in all_subj_traces_block_str.split('}, {') if t.strip()]

                    for trace_idx, trace_str in enumerate(individual_all_subj_traces):
                        if not trace_str.startswith('{'): trace_str = '{' + trace_str
                        if not trace_str.endswith('}'): trace_str = trace_str + '}'

                        if "hoverinfo: 'skip'" in trace_str:
                            continue
                        if not re.search(r'x:\s*\[\s*\]', trace_str):
                            hovertemplate_match = re.search(r"hovertemplate:\s*'(.*?)'", trace_str)
                            if not hovertemplate_match:
                                failures.append(f"Hovertemplate Check (allSubjTraces, plot_id {plot_id_str}, trace {trace_idx+1}): No hovertemplate found. Trace: {trace_str[:150]}...")
                            else:
                                ht = hovertemplate_match.group(1)
                                expected_ht = '전교과등급: %{x}<extra></extra>'
                                if not (ht == expected_ht or ht == '전교과등급: %{x}%<extra></extra>'):
                                    failures.append(f"Hovertemplate Check (allSubjTraces, plot_id {plot_id_str}, trace {trace_idx+1}): Incorrect. Expected '{expected_ht}', Got '{ht}'.")
                                if '{result}' in ht or '<br>' in ht:
                                     failures.append(f"Hovertemplate Check (allSubjTraces, plot_id {plot_id_str}, trace {trace_idx+1}): Found '{{result}}' or '<br>' in hovertemplate: '{ht}'.")
            except Exception as e:
                failures.append(f"Hovertemplate Check: Error processing script content for plotData (plot_id {plot_id_str}): {e}. Content snippet: {plot_data_str[:200]}...")

# Legend Symbol Check
print("\n--- Legend Symbol Check ---")
if not failures: 
    # Use greedy match for the wrapper content
    legend_wrapper_match = re.search(r'<div class="legend-items-wrapper">(.*)</div>', html_content, re.DOTALL)
    if not legend_wrapper_match:
        failures.append("Legend Symbol Check: <div class=\"legend-items-wrapper\"> not found.")
    else:
        legend_html_content_wrapper = legend_wrapper_match.group(1) 
        
        def normalize_html_string(html_str):
            def remove_style_spaces(match):
                return match.group(1) + match.group(2).replace(' ', '').replace('"',"'") + match.group(3) 
            
            s = html_str.replace('"', "'")
            s = re.sub(r"(style=')([^']*)(')", remove_style_spaces, s)
            
            s = re.sub(r'\s+', ' ', s) 
            s = re.sub(r"\s*;\s*", ";", s) 
            s = re.sub(r"\s*:\s*", ":", s) 
            s = re.sub(r"\s*>\s*<\s*", "><", s)
            s = s.replace("&amp;", "&").replace("&#9679;", "●").replace("&#9650;", "▲").replace("&#10005;", "✕").replace("&#10006;", "✖")
            return s.strip()

        normalized_legend_wrapper_content = normalize_html_string(legend_html_content_wrapper)
        # print(f"DEBUG: Normalized Legend Wrapper Content:\n{repr(normalized_legend_wrapper_content)}\n") # Keep for debugging if needed


        expected_legend_items_as_substrings = {
            "합격": normalize_html_string('<div class="legend-item"><span class="legend-marker legend-pass">●</span><span class="legend-text">합격 (Y축 상단)</span></div>'),
            "충원합격": normalize_html_string('<div class="legend-item"><span class="legend-marker legend-wait">▲</span><span class="legend-text">충원합격 (Y축 중앙)</span></div>'),
            "불합격": normalize_html_string('<div class="legend-item"><span class="legend-marker legend-fail">✖</span><span class="legend-text">불합격 (Y축 하단)</span></div>')
        }
        
        all_legends_found_correctly = True 
        for result_name, expected_item_str in expected_legend_items_as_substrings.items():
            # print(f"DEBUG: Checking for {result_name}. Expected substring:\n{repr(expected_item_str)}") # Keep for debugging if needed
            if expected_item_str not in normalized_legend_wrapper_content:
                failures.append(f"Legend Symbol Check ({result_name}): Expected legend item HTML not found or incorrect. \nExpected to find: {expected_item_str}\nIn block: {normalized_legend_wrapper_content}")
                all_legends_found_correctly = False
            # else:
                # print(f"DEBUG: Found legend for {result_name}.") # Keep for debugging if needed
        
        if all_legends_found_correctly: # This will only be true if no failures were appended in the loop above
             print("Legend Symbol Check: All expected legend items found and correct within the legend wrapper.")


# 5. Report results
print("\n--- Results ---")
final_summary = ""
succeeded_bool = False
if not failures:
    final_summary = "All checks passed successfully for hovertemplates and legend symbols."
    succeeded_bool = True
    print(final_summary)
else:
    final_summary = "One or more checks failed:\n" + "\n".join(f"- {f}" for f in failures)
    succeeded_bool = False
    print(final_summary)

# submit_subtask_report(succeeded=succeeded_bool, summary=final_summary) # This will be called by the main agent

print("\n--- Test Script Finished ---")
